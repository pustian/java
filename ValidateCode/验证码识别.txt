     处理第一步，去背景噪音和二值化
      对于这一块，考虑了几种方法。
      方法一，统计图片颜色分布，颜色占有率低的判定为背景噪音。由于背景噪音和前景色区分并不明显，尝试了很多种取景方法都不能很好去除背景噪音，最终放弃了这种方法。
      方法二，事后在网上稍微查了下，最近比较流行计算灰度后设定一个阈值进行二值化。其实所谓的灰度图片原理是根据人眼对色彩敏感度取了权值，这个权值对计算机来说没有什么意义。稍微想一下就可以发现，这两个过程完全可以合并。于是乎我一步完成了去背景噪音和二值化。阈值设置为RGB三分量之和到500。结果非常令人满意。

      处理第二步，制作字符样本
      样本对于计算机来说是非常重要的，因为计算机很难有逻辑思维，就算有逻辑思维也要经过长期训练才能让你满意。所以要用事先制作好的样本进行比较。如果你仔细观察过这些验证码会发现一个bug，几乎大部分的验证码都是使用同样的字体，于是乎就人工制作了一套字体的样本。由于上一步已经有去除背景噪音的结果，可以直接利用。制作样本这一步有点简单枯燥，还需要细心。可能因为你的一个不细心会导致某个符号的识别率偏低。在这500个样本中，只发现了31个字符。幸亏是某部门的某人员还考虑到了易错的字符，例如，1和I，0和O等。要不然这个某部门要背负更多的骂名。
 
      处理第三步，匹配
      单个匹配用了最简单最原始的二值比较，不过匹配的是匹配率而不是匹配数。我定义了相关的计分原则。大原则是“该有的有了加分，该有的没了减分，不该有的有了适度减分，可达区域外的不算分”。
      由于一些符号的部分区域匹配结果跟另一些符号的完整匹配结果相似，需要把单个匹配在一个扩大的区域内择优。在一定的范围内，找到一个最佳匹配，这个最佳匹配就是当前位置对应的符号。
      完成了一次最佳匹配，可以把匹配位置向右推进一大步，若找不到合适的最佳匹配就向右推进一小步。
 
      处理第四步，优化和调整
      任何一个算法都是需要优化和调整的。现在要找到最佳参数配置和最佳代码组织。这一步往往是需要花费最多时间和精力的。
 
      处理第五步，验证结果
      这一步呢，纯人力验证结果，统计出正确率。



1, 取出字模 识别验证码，毕竟不是专业的OCR识别，并且，由于各个网站的验证码各不相同，所以，最常见的方法就是就是建立这个验证码的特征码库。去字模时，我们需要多下载几张图片，使这些图片中，包括所有的字符，我们这里的字母只有图片，所以，只要收集到包括0-9的图片即可。 
2, 二值化 二值化就是把图片上的验证数字上每个象素用一种数字表示1，其他部分用0表示。这样就可以计算出每个数字字模，记录下这些字模来，当作key即可。 
3, 计算特征 把要识别的图片，进行二值化，得到图片特征。 
4, 对照样本 把步骤3种的图片特征码和验证码的字模进行对比，得到验证图片上的数字。 